Algorithm TRAPEZOIDALMAP(S)
Input. A set S of n non-crossing line segments.
Output. The trapezoidal map T(S) and a search structure D for T(S) in a bounding box.
    Guarantee startPoint is leftEndPint and endPoint is rightEndPiont, sorting to do so.
    Determine a bounding box R that contains all segments of S, 
    and initialize the trapezoidal map structure T and search structure D for it.
    T <- determineBoundingBox(S);
    D <- initialize;
    put T into D;
    Compute a random permutation s1, s2, ... sn of the elements of S.
    S' <- RANDOMPERMUTATION(S)
    for i <- 1 to n
        do Find the set D0, D1, ... , Dk of trapezoids in T properly intersected by si.
            Ds <- D0, D1, ... , Dk;
            Remove D0, D1, ... , Dk from T and replace them 
            by the new trapezoids that appear because of the insertion of si.
            updateTrapezoidalMap(Ds, si);
            Remove the leaves for D0, D1, ... , Dk from D, 
            and create leaves for the new trapezoids.
            Link the new leaves to the existing inner nodes 
            by adding some new inner nodes, as explained below.
            updateSearchStrcuture(Ds, si);

Algorithm FOLLOWSEGMENT(T, D, si)
Input. A trapezoidal map T, a search structure D for T, and a new segment si.
Output. The sequence D0; : : : ;Dk of trapezoids intersected by si.
    Let p and q be the left and right endpoint of si.
    Search with p in the search structure D to find D0.
    j <- 0;
    while q lies to the right of rightp(Dj)
        do if rightp(Dj) lies above si
            then Let Dj+1 be the lower right neighbor of Dj.
            else Let Dj+1 be the upper right neighbor of Dj.
        j <- j+1
    return D0,D1, ... , Dj


Algorithm RANDOMPERMUTATION(A)
Input. An array A[1...n].
Output. The array A[1...n] with the same elements, but rearranged into a random permutation.
    for k n downto 2
        do rndindex <- RANDOM(k)
            Exchange A[k] and A[rndindex].


determineBoundingBox(S)
    // all HalfEdges: toLeft(e) > 0
    offset <- 5
    topLeft <- ( xMin - offset, yMax + offset ) 
    topRight <- ( xMax + offset, yMax + offset )
    bottomLeft <- ( xMin - offset, yMin - offset )
    bottomRight <- ( xMax + offset, yMMin - offset )
    
    T <- initialize trapezoid A for the bounding box, DCEL
    T.leftUpperNeighbour = leftLowerNeighbour = HalfEdgeLeft
    T.rightUpperNeighbour = rightLowerNeighbour = HalfEdgeRight
    
    incidentFace pointing to innerFace
    T.top = HalfEdgeTop;
    T.bottom = HalfEdgeBottom;
    
    return T;
    
updateTrapezoidalMap(Ds, D, si)
    Let p and q be the left and right endpoint of si.
    
    de <- initialize a list
    for i <- 0 to Ds.length - 1
        flag <- Ds.length < 2
        do if i == 0 
                do d.parents = handleP(d, si, false | flag, de)
            if i == Ds.length - 1
                do d.parents = handleQ(d, si, false, de)
            else
                assert Ds.length > 1
                d.parents = handleS(d, si, true, de)
                    
    delete edges due to the intersection of and Ds and si
    trimWalls(de)
    
trimWalls(de)
    for i <- o to de.length - 1
        do assert rightNeighbors: upper == lower
        // f[0] remained one; f[1] deleted one
        f = delete(de[i].rightNeighbor)
        resetChild(f)
        addParent(f)